#!/usr/bin/env sh

# TODO: Add more comments.
# TODO: Remove the need to have a fallback img.
# TODO: Error for invalid options.

# Start swww daemon if it's not running already.
[ -z "$(pgrep swww)" ] && swww init >/dev/null 2>&1

# Setup cache directories & specify location for the reload file with it:
cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/waybg"
cache_imgs="$cache_dir/imgs"
rofi_img_dir="${XDG_CONFIG_HOME:-$HOME/.config}/rofi/images"
librewolf_img_dir="$HOME/.librewolf/vnmkhf5p.default-default/chrome"
[ ! -d "$cache_dir" ] && mkdir -p "$cache_dir"
[ ! -d "$cache_imgs" ] && mkdir -p "$cache_imgs"
reload_file="$cache_dir/wallpaper"

# Fallback image:
fallback_img="$HOME/Pictures/wallpapers/black.png"

#: Help page {{{
# Function to display waybg's help page:
help_page(){
yellow="$(tput bold; tput setaf 3)"
blue="$(tput bold; tput setaf 4)"
reset="$(tput sgr0; tput bold)"

cat << EOF
${yellow}DESCRIPTION:${reset}
        Waybg is a tool to set your wallpaper on wayland compositors,
        it allows you to set images/videos/youtube videos as your wallpaper using swww and mpvpaper.

${yellow}OPTIONS:${reset}
        This option reloads the previously set wallpaper based on waybg's cache file.
        NOTE: The default cache location is at ~/.cache/waybg/wallpaper.

${blue}    -a | --audio)${reset}
        This option enables audio for video wallpapers.
        NOTE: this option is ignored when the reload option is already in use, instead if
        the previously set wallpaper had audio enabled it will also have it enabled by default when reloaded.

${blue}    --recurse <number>)${reset}
        Recursively search for valid image/video files inside a directory descending the amount of levels specified (a positive integer),
        a value of 0 can be used for infinite recursiveness.

${blue}    --use-fd)${reset}
        By default when using --recurse waybg will use GNU's find command to do the recursive searching,
        when this option is enabled waybg will try to use Sharkdp's fd command instead.
        NOTE: fd is a rust replacement to find and generally performs better than it,
        The github repo for the project can be found here: https://github.com/sharkdp/fd

${blue}    --mimes)${reset}
        By default when a directory path is given waybg will do a regex search for files with a file extension that matches the supported
        ones by swww/mpvpaper, however when this option is used the file mimetypes are going to be used as a result of the search instead.
        This can be useful if you're not sure if a certain directory contains images/videos or not, in case their file extensions are missing.
        WARNING: altho using a mimetype search is a good way to make sure only supported files will be filtered out, it's strongly recommended to
        not use this option on folders that have alot of content on them as a mimetype search is FAAAAAAAAR slower than a regex search, specially
        when --recurse is also in use.

${blue}    -Q | --silent)${reset}
        Supress error/success messages, this option can be useful for scripting.

${blue}    -h | --help)${reset}
        Display this help message and exit with error code 0 (which means the script ran successfully).
$(tput sgr0)
EOF

exit 0
}
#: }}}
#: Error/success functions: {{{
# Function to display error messages:
errcode(){
	[ -n "$silent" ] && exit 1
	red="$(tput setaf 1)"
	bold="$(tput bold)"
	reset="$(tput sgr0)"
	err_txt="${bold}${red}ERROR: ${reset}${bold}"
	case "$@" in
		1) echo "${err_txt}make sure to specify some option or some directory path/file path/video url!" ;;
		2) echo "${err_txt}no valid file was found inside the specified directory, try increasing the recursiveness value for directory searches with the -f option." ;;
		3) echo "${err_txt}the value '$recurse' used for --recurse is invalid, it must either be a positive integer or 0." ;;
		4) echo "${err_txt}the new specified wallpaper '$wall' is already in use" ;;
	esac
	exit 1
}

# Function to display success messages:
success_code(){
	[ -n "$silent" ] && exit 0
	blue="$(tput setaf 4)"
	bold="$(tput bold)"
	reset="$(tput sgr0)"
	success_txt="${bold}${blue}SUCCESS: ${reset}${bold}"
	case "$@" in
		1) echo "${success_txt}successfully changed wallpaper to the image $wall" ;;
		2) echo "${success_txt}successfully changed wallpaper to the video $wall" ;;
	esac
	exit 0
}
#: }}}
#: Mkreload function {{{
# Function to create reload file:
mkreload(){
	if [ -z "$audio" ]; then
		echo "$@" > "$reload_file"
	else
		echo "$@" > "$reload_file"
		echo 'true' >> "$reload_file"
	fi
}
#: }}}
#: Read options {{{
# All options are read by this while loop:
while [ "$1" ]
do
	case "$1" in
		'-r' | '--reload') reload='true' ;;
		'-a' | '--audio') audio='true'   ;;
		'--recurse') recurse="$2"        ;;
		'--use-fd') use_fd='true'        ;;
		'--mimes') mimes='true'          ;;
		'-Q' | '--silent') silent='true' ;;
		'-h' | '--help') help_page       ;;
		'-'*) help_page                  ;;
	esac

	# Make sure the wallpaper path is the last argument to be read.
	wall="$1"; shift
done

# Reload previous wallpaper if specified
[ -n "$reload" ] && wall="$(readlink -f -- "$(head -n1 "$reload_file")")"

# Error if no file/directory/option/URL was specified:
[ -z "$wall" ] && errcode 1
#: }}}
#: Directory searching {{{
# Function to find a random file without using mimetypes:
find_random_file(){
	search_regex='.*\.(jpeg|jpg|png|gif|pnm|tga|tiff|webp|bmp|farbfelp|mp4|mov|wmv|flv|avi|webm|mkv)$'
	directory="$1"
	use_fd="$2"
	maxdepth="$3"

	if [ -z "$use_fd" ]; then
		find "$directory" -maxdepth "$maxdepth" -type f -regextype posix-extended -regex "$search_regex"
	else
		fd "$search_regex" "$directory" --type f --max-depth "$maxdepth"
	fi | shuf -n1
}

# Function to find a random file with mimetypes:
find_random_file_with_mimes(){
    directory="$1"
    use_fd="$2"
    maxdepth="$3"

    if [ -z "$use_fd" ]; then
        find "$directory" -maxdepth "$maxdepth" -type f -exec file -LF '§§' --mime-type "{}" \;
    else
        fd . "$directory" --type f --max-depth "$maxdepth" --exec file -LF '§§' --mime-type "{}" \;
    fi | awk 'BEGIN {FS = "§§"} /§§\s+(image|video)\/.*/ {print $1}' | shuf -n1
}

[ -z "$reload" ] && [ -d "$wall" ] &&
	case "$mimes" in
		'')
			# Determine the depth and find a random file accordingly:
			if [ -z "$recurse" ]; then
				wall="$(find_random_file "$wall" "$use_fd" 1)"
			elif [ "$recurse" -gt 0 ]; then
				wall="$(find_random_file "$wall" "$use_fd" "$recurse")"
			elif [ "$recurse" -eq 0 ]; then
				wall="$(find_random_file "$wall" "$use_fd")"
			else
				errcode 3
			fi

			# Error if no valid file was found inside the specified directory:
			[ -z "$wall" ] && errcode 2
		;;

		*)
			# Determine the depth and find a random file accordingly:
			if [ -z "$recurse" ]; then
				wall="$(file -LF '§§' --mime-type "${wall%%/}"/* | awk 'BEGIN {FS = "§§"} /§§\s+(image|video)\/.*/ {print $1}' | shuf -n1)"
			elif [ "$recurse" -gt 0 ]; then
				wall="$(find_random_file_with_mimes "$wall" "$use_fd" "$recurse")"
			elif [ "$recurse" -eq 0 ]; then
				wall="$(find_random_file_with_mimes "$wall" "$use_fd")"
			else
			    errcode 3
			fi

			# Error if no valid file was found inside the specified directory:
			[ -z "$wall" ] && errcode 2
		;;
	esac
#: }}}
#: Set wallpaper {{{
# Function to kill mpvpaper related processes:
kill_mpvpaper() {
	killall -q display mpvpaper ffmpeg 2>/dev/null
	while pgrep -x display >/dev/null || pgrep -x mpvpaper >/dev/null || pgrep -x ffmpeg >/dev/null; do sleep 0.1; done
}

set_wallpaper(){
	file="$1"

	# Switch wallpaper to specified image.
	swww img "$file" --resize crop

	# Make reload file, link original wallpaper to a cache file and exit with success code:
	printf '%s\n' "$cache_dir/wall.png" "$librewolf_img_dir/wall.png" "$rofi_img_dir/wall.png" | xargs -I {} ln -sf "$file" "{}"
	mkreload "$file" && success_code 1
}

set_video_wallpaper(){
	file="$1"
	cache_file="$2"

	# Check if the fallback black image is currently set, if not set it as the current wallpaper.
	[ -z "$(swww query | grep "$fallback_img")" ] && swww img "$fallback_img" --resize crop && sleep "${SWWW_TRANSITION_DURATION:-1}"

	# Set specified video as the new wallpaper, enabling audio if specified.
	[ -z "$audio" ] && mpvpaper_opts='--no-audio'
	mpvpaper -fo "--loop $mpvpaper_opts" '*' "$file"

	# Make reload file, link original wallpaper to a cache file and exit with success code:
	printf '%s\n' "$cache_dir/wall.png" "$librewolf_img_dir/wall.png" "$rofi_img_dir/wall.png" | xargs -I {} ln -sf "$cache_file" "{}"
	mkreload "$file" && success_code 2
}

# Determine the type of file and set wallpaper accordingly:
case "$(file --mime-type -Lb "$wall" | tr '[:upper:]' '[:lower:]')" in
	'image/'*)
		# If a image file is used, kill current wallpaper processes, and set as wallpaper.
		kill_mpvpaper; set_wallpaper "$wall" ;;
	'video/'*)
		# If a video file is used, extract thumbnail with ffmpeg, kill current wallpaper processes, and set video wallpaper:
		cache_file="$cache_imgs/thumb-$(stat --printf '%n\0%i\0%F\0%s\0%W\0%Y' -- "$(readlink -f "$wall")" | sha256sum | cut -d' ' -f1).png"
		[ ! -f "$cache_file" ] && ffmpeg -y -i "$wall" -frames:v 1 "$cache_file"
		kill_mpvpaper; set_video_wallpaper "$wall" "$cache_file"
	;;

	# Set video wallpaper if it's a youtube url:
	http://youtu.be/* | http://*www.youtube.com/* | https://youtu.be/* | https://*www.youtube.com/*)
		# If a YouTube URL is used, download thumbnail with yt-dlp, kill current wallpaper processes, and set video wallpaper:
		cache_file="$cache_imgs/thumb-$(echo "$wall" | sha256sum | cut -d' ' -f1).png"
		[ ! -f "$cache_file" ] && yt-dlp --write-thumbnail --convert-thumbnails png --skip-download "$wall" --output "${cache_file%%.png}"
		kill_mpvpaper; set_video_wallpaper "$wall" "$cache_file"
	;;

	'') help_page ;;
	*) errorcode 1 ;;
esac
#: }}}

# vim:fileencoding=utf-8:foldmethod=marker
